😅 使用 input 读入一个数字
let a = input

😅 C 里面的所有中缀操作符，例如 + * % & && > !=，全部支持！
let b = a * a % 6

😅 使用匿名函数的形式创建函数
let f = (x: int) => x + 1

😅 Silent-Lang 有常量折叠，下面的数会在编译期被计算成 5！
let five = f(4)

😅 使用 print 函数输出值
let _ = print(f(b * five))

😅 Silent-Lang 支持无括号元组！
let c, d = 113, a

😅 元组可以打包
let pair = 1, a

😅 元组还能作为函数参数
let add = (p: int, int) =>

  😅 元组可以解包
  let x, y = p
  x + y

😅 编译期计算依然能起到作用！c + 1 会被直接计算成 114
let _ = print(add(c, 1))

😅 也可以直接令 pair 为函数参数
let _ = print(add(pair))

😅 元组也能经过 if 语句
let g, h = if d > 5 then 4, 4 else 8, 8
let _ = print(g * h)

😅 Silent-Lang 有更适合 FP 宝宝体质的 while 循环！假设要计算 1 + 2 + ... + n：
let res, n = 0, a rec
  
  😅 如果 n = 0，res 已经是最终结果，拒绝进行状态转移
  if n == 0 then nope else

  😅 否则计算下一状态的 res 和 n 并转移
  res + n, n - 1

😅 输出结果看看对不对！
let _ = print(res)

😅 感觉不理解？用 rec 还可以写阶乘：
let res, n = 1, a rec

  😅 如果 n = 1，res 已经是最终结果，拒绝进行状态转移
  if n == 1 then nope else

  😅 否则计算下一状态的 res, n 并转移
  res * n, n - 1

😅 输出结果看看对不对！
let _ = print(res)

😅 用 rec 还可以计算斐波那契数列：
let last, res, n = 1, 1, a rec
  
  😅 如果 n < 2，res 已经是最终结果，拒绝进行状态转移
  if n < 2 then nope else

  😅 否则计算下一状态的 last, res, n 并转移
  res, last + res, n - 1

😅 输出结果看看对不对！
let _ = print(res)

😅 还能算快速幂！res 将被计算为 a 的 p 次方
let a, p, res = input, input, 1 rec

  😅 如果 p = 0，res 直接就是结果
  if p == 0 then nope else

  😅 否则假如 p 是奇数，就需要给结果乘上 a
  let next = if p & 1 > 0 then res * a else res

  😅 转移结果
  a * a, p / 2, next

😅 输出结果看看对不对！
let _ = print(res)

😅 后续如果我有空，还会做数组喵
0

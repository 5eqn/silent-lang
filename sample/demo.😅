👉 
   欢迎体验绷语言，Silent-Lang！
   我们使用 😅 表示开始「行注释」，相当于 C 语言的 //
   同时，左右手指之间的是「块注释」，相当于 C 语言的 /* */
   你有没有发现，这一段话就是块注释的内容？
👈

😅 使用 input 读入一个数字
let a = input

😅 C 里面的大部分中缀操作符，例如 + * % & && > !=，全部支持！
let b = a * a % 6

😅 使用匿名函数的形式创建函数
let f = (x: int) => x + 1

😅 下面的数会在编译期被计算为 5，不会调用 f 函数造成额外性能开销！
let five = f(4)

😅 使用 print 函数输出值
let _ = print(f(b * five))

👉
   Silent-Lang 有用起来「非常舒服」的无括号元组！
   一句话概括，how you expect it to work, how it WILL work.
   无括号元组编译后会被变成一个个单独的变量，
   不会造成任何额外性能开销！
👈

😅 令 c, d, mmsd 分别为 113, a, 9
let c, d, mmsd = 113, a, 9

😅 元组可以打包
let pair = 1, input

😅 元组还能作为函数参数
let add = (p: int, int) =>

  😅 元组可以解包
  let x, y = p
  x + y

😅 可以直接令 pair 为函数参数
let e = add(pair)

😅 也可以指定元组的两个值，可以任意重组！
let res = add(five, e)
let _ = print(res)

👉 
   Silent-Lang 有更适合 FP 宝宝体质的 while 循环！
   假设要计算 1 + 2 + ... + n: 
👈

😅 res 和 n 的初始值分别是 0 和 input，但其会按照 rec 后的内容进行「状态更新」
let res, n = 0, input rec
  
  😅 如果 n = 0，res 已经是最终结果，拒绝更新状态
  if n == 0 then nope else

  😅 否则计算下一状态的 res 和 n 并更新
  res + n, n - 1

😅 输出结果看看对不对！
let _ = print(res)

😅 感觉不理解？用 rec 还可以写阶乘：
let res, n = 1, input rec

  😅 如果 n = 1，res 已经是最终结果，拒绝更新状态
  if n == 1 then nope else

  😅 否则计算下一状态的 res, n 并更新
  res * n, n - 1

😅 输出结果看看对不对！
let _ = print(res)

😅 用 rec 还可以计算斐波那契数列：
let last, res, n = 1, 1, input rec
  
  😅 如果 n <= 2，res 已经是最终结果，拒绝更新状态
  if n <= 2 then nope else

  😅 否则计算下一状态的 last, res, n 并更新
  res, last + res, n - 1

😅 输出结果看看对不对！
let _ = print(res)

😅 还能算快速幂！res 将被计算为 a 的 p 次方
let a, p, res = input, input, 1 rec

  😅 如果 p = 0，res 直接就是结果
  if p == 0 then nope else

  😅 否则假如 p 是奇数，就需要给结果乘上 a
  let next = if p & 1 > 0 then res * a else res

  😅 转移结果
  a * a, p / 2, next

😅 输出结果看看对不对！
let _ = print(res)

😅 小挑战：怎么用 silent-lang 写个二分，以求出根号 n 的值？
let n = input
let l, u = 0, 46340 rec
  if l + 1 == u then nope else
  let mid = (l + u) / 2
  if mid * mid <= n
  then mid, u
  else l, mid

😅 输出结果看看对不对！
let _ = print(l)

😅 后续如果我有空，还会做数组喵
0
